---
phase: 02-core-metrics
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/core/metrics/linter.ts
  - src/core/metrics/linter.test.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript/JavaScript projects report eslint error count"
    - "Python projects report ruff/flake8 error count"
    - "Go projects report golangci-lint error count"
    - "Missing linter returns graceful failure"
  artifacts:
    - path: "src/core/metrics/linter.ts"
      provides: "Lint error measurement"
      exports: ["measureLintErrors", "LINTER_TOOLS"]
    - path: "src/core/metrics/linter.test.ts"
      provides: "Tests for linter"
      min_lines: 30
  key_links:
    - from: "linter.ts"
      to: "runner.ts"
      via: "runTool import"
      pattern: "import.*runTool.*from.*runner"
---

<objective>
Implement lint error measurement across languages.

Purpose: Enable BTAR to report linter errors (eslint, ruff, golangci-lint, etc.) for detected languages.
Output: measureLintErrors function that runs appropriate linter and parses error count.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-metrics/02-01-SUMMARY.md

@src/core/types.ts
@src/core/metrics/types.ts
@src/core/metrics/runner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Linter Tool Mapping</name>
  <files>src/core/metrics/linter.ts</files>
  <action>
Create linter measurement:

1. LINTER_TOOLS constant mapping SupportedLanguage → tool info:
   - typescript: { tool: "eslint", command: ["npx", "eslint", ".", "--format", "json"], parseErrors: fn }
   - javascript: { tool: "eslint", command: ["npx", "eslint", ".", "--format", "json"], parseErrors: fn }
   - python: { tool: "ruff", command: ["ruff", "check", ".", "--output-format", "json"], parseErrors: fn }
     (fallback: flake8 if ruff not found)
   - go: { tool: "golangci-lint", command: ["golangci-lint", "run", "--out-format", "json"], parseErrors: fn }
   - java: { tool: "checkstyle", command: ["checkstyle", "-c", "/google_checks.xml", "."], parseErrors: fn }
   - swift: { tool: "swiftlint", command: ["swiftlint", "lint", "--reporter", "json"], parseErrors: fn }
   - kotlin: { tool: "ktlint", command: ["ktlint", "--reporter=json"], parseErrors: fn }
   - ruby: { tool: "rubocop", command: ["rubocop", "--format", "json"], parseErrors: fn }
   - php: { tool: "phpcs", command: ["phpcs", "--report=json"], parseErrors: fn }

2. Error parsing functions per tool:
   - eslint JSON: Sum of errorCount across all files
   - ruff JSON: Length of diagnostics array
   - golangci-lint JSON: Count issues array
   - Others: Count lines with error patterns

3. measureLintErrors function:
   ```typescript
   async function measureLintErrors(
     language: SupportedLanguage,
     directory: string
   ): Promise<MetricResult>
   ```
   - Look up tool for language
   - Run tool via runTool
   - Parse output (prefer JSON format for reliable parsing)
   - Return MetricResult

4. Handle edge cases:
   - No eslint config → tool may error, capture that
   - Tool not installed → success: false, value: -1
   - No files to lint → success: true, value: 0
  </action>
  <verify>npm run build succeeds</verify>
  <done>measureLintErrors exported, handles all supported languages</done>
</task>

<task type="auto">
  <name>Task 2: Add Linter Tests</name>
  <files>src/core/metrics/linter.test.ts</files>
  <action>
Create tests for linter:

1. Test LINTER_TOOLS mapping:
   - typescript has eslint tool
   - python has ruff tool
   - All languages have a defined linter

2. Test error parsing functions (unit tests):
   - Parse sample eslint JSON output
   - Parse sample ruff JSON output
   - Parse sample golangci-lint JSON output

3. Test measureLintErrors behavior (mock runner):
   - Mock runTool to return sample JSON output
   - Verify correct error count extracted
   - Verify tool-not-found handled gracefully

Pattern: Use vitest, test parsing logic in isolation
  </action>
  <verify>npm test passes</verify>
  <done>Tests cover tool mapping, JSON parsing, and measureLintErrors logic</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm test` passes
- [ ] measureLintErrors handles all 9 supported languages
- [ ] JSON parsing tested with realistic sample output
- [ ] Tool-not-found case handled gracefully
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- All supported languages have linter mapping
- JSON output parsing is robust
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-metrics/02-03-SUMMARY.md`
</output>
