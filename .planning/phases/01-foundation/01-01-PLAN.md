---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/index.ts
  - .gitignore
  - README.md
autonomous: true
must_haves:
  truths:
    - "npm install succeeds without errors"
    - "npm run build produces dist/ directory"
    - "TypeScript strict mode is enabled"
  artifacts:
    - path: "package.json"
      provides: "NPM package definition with bin entry"
      contains: '"bin":'
    - path: "tsconfig.json"
      provides: "TypeScript configuration with strict mode"
      contains: '"strict": true'
    - path: "src/index.ts"
      provides: "Module entry point"
  key_links:
    - from: "package.json bin"
      to: "dist/cli.js"
      via: "CLI invocation path"
      pattern: '"btar":.*"dist/cli.js"'
---

<objective>
Scaffold BTAR CLI project with TypeScript, Node.js, and npm package structure.

Purpose: Establish foundation for all subsequent development - build system, type checking, package structure.
Output: Working npm package that can build and will eventually expose `btar` CLI command.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md

This is a greenfield project - no existing source code.

**Tech decisions:**
- TypeScript for type safety (aligned with BTAR's core value: "verification enables automation")
- Node.js >= 18 (LTS)
- Commander.js for CLI framework (de facto standard)
- ESM modules (modern Node.js)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize npm package with TypeScript</name>
  <files>package.json, tsconfig.json, .gitignore</files>
  <action>
    1. Create package.json with:
       - name: "btar"
       - version: "0.1.0"
       - type: "module" (ESM)
       - bin: { "btar": "dist/cli.js" }
       - main: "dist/index.js"
       - scripts: build (tsc), clean, dev, test (vitest)
       - devDependencies: typescript, @types/node, vitest
       - dependencies: commander (^12.x), yaml (^2.x)
       - engines: { "node": ">=18" }

    2. Create tsconfig.json with:
       - target: "ES2022"
       - module: "NodeNext"
       - moduleResolution: "NodeNext"
       - strict: true
       - outDir: "dist"
       - rootDir: "src"
       - declaration: true
       - esModuleInterop: true

    3. Create .gitignore with:
       - node_modules/
       - dist/
       - coverage/
       - .DS_Store
       - *.log

    AVOID: CommonJS patterns (require, module.exports). Use ESM imports/exports.
    WHY: ESM is the modern standard, avoids dual-module complexity.
  </action>
  <verify>
    - npm install completes without errors
    - package.json has "type": "module"
    - tsconfig.json has "strict": true
  </verify>
  <done>
    - package.json exists with correct structure
    - tsconfig.json exists with strict mode
    - npm install succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create source directory structure and entry points</name>
  <files>src/index.ts, src/cli.ts</files>
  <action>
    1. Create src/index.ts as module entry:
       - Export version from package.json
       - Export placeholder for main API (analyzer function)

    2. Create src/cli.ts as CLI entry:
       - Import Commander
       - Create basic program with name "btar", description, version
       - Add placeholder analyze command (will be implemented in 01-04)
       - Export program for testing
       - Add shebang: #!/usr/bin/env node

    Structure goal:
    ```
    src/
    ├── index.ts       # Module entry (for library use)
    ├── cli.ts         # CLI entry (for command line)
    ├── commands/      # Command implementations (01-04)
    └── core/          # Core logic (01-02, 01-03)
    ```

    AVOID: Implementing full analyze logic here - just scaffolding.
    WHY: Keeps this plan focused; real implementation comes in subsequent plans.
  </action>
  <verify>
    - npm run build succeeds
    - dist/cli.js exists with shebang
    - dist/index.js exists
    - node dist/cli.js --help shows usage
  </verify>
  <done>
    - src/index.ts exports version
    - src/cli.ts shows help with --help flag
    - Build produces working CLI stub
  </done>
</task>

<task type="auto">
  <name>Task 3: Create README and verify package structure</name>
  <files>README.md</files>
  <action>
    Create README.md with:
    - Project name and tagline ("Transform brownfield codebases into agent-ready environments")
    - Installation: npm install -g btar (future)
    - Usage: btar analyze . (placeholder)
    - Development: npm install, npm run build, npm run dev
    - License: MIT

    Keep minimal - this is scaffolding, not documentation phase.
  </action>
  <verify>
    - README.md exists
    - npm run build still works
    - npm pack produces btar-0.1.0.tgz
  </verify>
  <done>
    - README.md provides basic project info
    - Package can be built and packed
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm install completes without errors
- [ ] npm run build produces dist/ with cli.js and index.js
- [ ] node dist/cli.js --help shows program name "btar" and version
- [ ] TypeScript compiles with no errors (strict mode)
- [ ] Package structure matches expected layout
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- CLI stub responds to --help
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
